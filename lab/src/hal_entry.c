/***********************************************************************************************************************
* Copyright (c) 2020 - 2024 Renesas Electronics Corporation and/or its affiliates
*
* SPDX-License-Identifier: BSD-3-Clause
***********************************************************************************************************************/

#include "hal_data.h"
#include <stdio.h>
FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER
/* SREG pay-load size */
#define SREG_SIZE                       (0x03)
/* Status register pay-load */
#define STATUS_REG_PAYLOAD              {0x01,0x40,0x00}
uint8_t   data_sreg[SREG_SIZE]          = STATUS_REG_PAYLOAD;

volatile uint32_t system_flags = {0x00000003};
extern bsp_leds_t g_bsp_leds;
#if 1
void set_flash_index(int idx);

void print_header(struct boot_rsp *p_rsp);
void print_header(struct boot_rsp *p_rsp)
{
    printf("\nboot_rsp rsp = \r\n");
    printf("  id: %x *hdr: 0x%08X off: 0x%08X\r\n",
    p_rsp->br_flash_dev_id,
    (uint32_t) p_rsp->br_hdr,
    p_rsp->br_image_off);
    printf("         hdr-> magic: %08X hdr_size: 0x%X\n               img_size: 0x%X load_addr: 0x%08X",
            p_rsp->br_hdr->ih_magic,
            p_rsp->br_hdr->ih_hdr_size,
            p_rsp->br_hdr->ih_img_size,
            p_rsp->br_hdr->ih_load_addr);
    printf("\n               flags: 0x%08X\r\n",p_rsp->br_hdr->ih_flags);
}
#endif

/* Quick setup for MCUboot.
 *
 * To update the linker regions of an application to be used with this bootloader, add a the *.bld file created during the
 * build as a File property in e2 studio or RASC under Project > Properties, then C/C++ Build > Build Variables with variable
 * name BootloaderDataFile.
 * If QSPI is used, the QSPI flash must be initialized in Extended-SPI mode by calling R_QSPI_Open() before boot_go() is called.
 */
void mcuboot_quick_setup()
{
    fih_ret fstat;
#ifdef MCUBOOT_USE_MBED_TLS

    /* Initialize mbedtls. */
    mbedtls_platform_context ctx = {0};
    assert(0 == mbedtls_platform_setup(&ctx));
#elif (defined(MCUBOOT_USE_TINYCRYPT) && defined(RM_MCUBOOT_PORT_USE_TINYCRYPT_ACCELERATION))

    /* Initialize TinyCrypt port. */
    assert(FSP_SUCCESS == RM_TINCYRYPT_PORT_Init());
#elif (defined(MCUBOOT_USE_USER_DEFINED_CRYPTO_STACK))

/* Initialize Custom Crypto (Protected Mode) driver. */
    assert(FSP_SUCCESS == R_SCE_Open(&sce_ctrl, &sce_cfg));
#endif

    /* (Optional, not required if --pad is used during signing) To check for updates, call boot_set_pending. */
    bool update = 0;
    if (update)
    {
        boot_set_pending(0);
    }
//    struct boot_rsp {
        /** A pointer to the header of the image to be executed. */
//        const struct image_header *br_hdr;

        /**
         * The flash offset of the image to execute.  Indicates the position of
         * the image header within its flash device.
         */
//        uint8_t br_flash_dev_id;
//        uint32_t br_image_off;
//    };

    /* Verify the boot image and get its location. */
    struct boot_rsp rsp;
    struct boot_rsp rsp_resource;
    printf("\ncalling boot_go(0)\n");
    set_flash_index(0);
    fstat = boot_go(&rsp);
    printf("\n returned from boot_g(0) with status=%d\n",fstat);
    print_header(&rsp);

    //@@ change the flash map...
    set_flash_index(1);
    printf("\ncalling boot_go(1)\n");
    fstat = boot_go(&rsp_resource);

    printf("\n returned from boot_g(1) with status=%d",fstat);
    print_header(&rsp_resource);

    while(fstat);

    /* Enter the application. */
    RM_MCUBOOT_PORT_BootApp(&rsp);
}

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    R_BSP_PinAccessEnable();
    R_QSPI_Open(&g_qspi0_ctrl, &g_qspi0_cfg);
    err = R_ICU_ExternalIrqOpen(&g_SW1_ctrl, &g_SW1_cfg);
    err != R_ICU_ExternalIrqEnable(&g_SW1_ctrl);



    printf(__DATE__);printf("   ");printf(__TIME__);
    printf("***************************************************\r\n");
    printf("Press SW1\r\n");
    /* write enable for further operations */
    err = R_QSPI_DirectWrite(&g_qspi0_ctrl, &(g_qspi0_cfg.write_enable_command), 1, false);
    if(FSP_SUCCESS == err)
    {
        err = R_QSPI_DirectWrite(&g_qspi0_ctrl, data_sreg, SREG_SIZE, false);
        if(FSP_SUCCESS != err)
        {
            while(1);
        }
    }
    R_BSP_PinWrite((bsp_io_port_pin_t) g_bsp_leds.p_leds[0], BSP_IO_LEVEL_HIGH);
while(system_flags & 0x00000001);  // wait for button press.
R_BSP_PinWrite((bsp_io_port_pin_t) g_bsp_leds.p_leds[0], BSP_IO_LEVEL_LOW);
    mcuboot_quick_setup();
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}


/* Callback function */
void SW1_cb(external_irq_callback_args_t *p_args)
{
    /* TODO: add your own code here */
    system_flags &= 0xFFFFFFFE;
}



#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
